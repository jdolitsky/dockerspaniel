#!/usr/bin/env node
var fs = require('fs');
var ARGV = require('yargs')
    .default('t',undefined)
        .alias('t','tag')
    .default('b',undefined)
        .alias('b','base')
    .default('i',undefined)
        .alias('i','input')
    .default('o',undefined)
        .alias('o','output')
    .argv;

var die = function (msg) {
    console.error(msg);
    process.exit(1);
};

var determineBaseImage = function(base_image) {
    var prefix = '\nFROM ';
    if (ARGV.b) { return prefix + ARGV.b; }
    if (base_image) { return prefix + base_image; }
    die('No base image provided. (Try --base ubuntu:12.04)');
};

var determineSpanielfile = function () {
    if (ARGV.i) { return ARGV.i; }
    return 'Spanielfile';
};

var determineDockerfile = function () {
    if (ARGV.o) { return ARGV.o; }
    return 'Dockerfile';
};

var docker = function(spaniel, tag_obj) {
    var content = '#\n#   generated by DockerSpaniel\n#';

    content += determineBaseImage(spaniel.from);

    if (spaniel.maintainer) {
        content += '\nMAINTAINER '+spaniel.maintainer+'\n'; 
    }

    var num_steps = spaniel.steps.length;
    var step = undefined;
    var i, j, skip;
    for (i = 0; i < num_steps; i++) {
        step = spaniel.steps[i];

        // if tag in 'unless' array is present, do not make step
        if (step.unless && step.unless.length) {
            skip = false;
            for (j=0; j<step.unless.length; j++) {
                if (tag_obj[step.unless[j]]) {
                    skip = true;
                    break;
                }
            }
            if (skip) { continue; }
        }
        
        // only make step if tag in 'only' array is present
        if (step.only && step.only.length) {
            skip = false;
            for (j=0; j<step.only.length; j++) {
                if (!tag_obj[step.only[j]]) {
                    skip = true;
                    break;
                }
            }
            if (skip) { continue; }
        }

        if (step.comment || step.newline) { content += '\n'; }
        if (step.comment) { content += '# '+step.comment+'\n'; }
        content += step.instruction.toUpperCase()+' ';
        content += step.arguments+'\n';
    }

    var docker_file = determineDockerfile();

    fs.writeFile(docker_file, content, function(err) {
        if(err) { die('Could not write to '+docker_file+': '+err); }
        console.log(docker_file+' generated.');
        process.exit(0);
    });
};

var createTagObject = function () {
    var tag_obj = {};
    if (ARGV.t) {
        if (typeof ARGV.t === 'string'){
            tag_obj[ARGV.t]=true;
        }
        else {
            for (var i=0;i<ARGV.t.length; i++) {
                tag_obj[ARGV.t[i]]=true;
            }
        }
    }
    return tag_obj;
};

var main = function () {
    var spaniel_file = determineSpanielfile();

    fs.readFile(spaniel_file, 'utf8', function (err, data) {
        if (err) { die('Could not read '+spaniel_file+': '+err); }
        var spaniel = undefined;
        try { spaniel = JSON.parse(data); }
        catch (e) { die(spaniel_file+' is not valid JSON: '+e); }
        var tag_obj = createTagObject();
        docker(spaniel, tag_obj);
    });
};

main();
